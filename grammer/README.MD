## 1. 数据类型变量
Python程序中所有数据都由对象或对象之间的关系表示。
* 动态数据类型，先为数据分配空间，然后让变量指向它。
* 整型，浮点型：     表示范围，所占用内存， 基础变量方式？
* 布尔型， 字符型： 不同类型相互转化？
* 空值： None         不同类型的表示方法， 若是变量未定义只是声明，这个变量什么值？
* 字面值常量的默认类型？
* 字符串编码： 显示指定编码方式，特别是对于中文字符串， 默认的字符串时ASCII编码而ASCII不支持中文。
* list , tuple： 可变与不可变的元素集合。

## 2. 逻辑控制
* if else elif
* for in  主动遍历可迭代对象的所有元素。可以判断一个对象是否可迭代，可以同时迭代对象中的索引和值。
* while 手动确定循环条件。

## 3. 函数
* 关键字: def；return 可以隐式的返回多个值。
* 参数： 
    * 默认参数： 默认参数必须指向不变对象。
    * 可变参数： 添加\*指定。	
    * 关键字参数：\*\*指定， 多个含名参数转化成dict传入使用。
    * 必选参数、默认参数、可变参数和关键字参数。
* generator : 生成器函数， yield关键字定义函数执行逻辑， yield 的位置类似于确定了迭代点，所以可以通过for循环来访问 生成器函数.
* 匿名函数： 关键字，lambada，只能是一个表达式，没有return值。
* 装饰函数：
* 偏函数： 将函数的某个参数固定，返回一个新的函数对象。 functools.partial
* 总结： 与JS逻辑相似，多封装了一些功能而已。

## 4. 作用域的概念
不存在{}局部作用域。只有函数作用域。
也有闭包概念，实现的方式也是类似，可以通过闭包来实现局部作用域；
## 5. 模块机制
与nodejs类似， 通过模块提高代码复用度。
引入 import, 输出方式不一样， import文件中的所有方法都可以通过库名访问到，没有限制。
引入文件时也会执行一遍其中的代码，与 require类似。

## 6. 面向对象
### 6.1 封装：
* 关键字： class
* 特征: 
     * 动态的类型, 可以动态的为类型和实例添加属性和方法;
     * 强类型语言, 提供了完整的封装与继承多态特性，与JS不同; 
* 属性与方法
    * 基础属性，方法:
        * \_\_init\_\_(self, argv): \_\_init__ 构造函数;
        * private: 双下划线开头的变量，只能内部访问;
* 用于定制类型的变量：
    * \_\_slots\_\_： 通过\_\_slots__属性指定能够动态添加的属性。
    * @property:  将一个方法变成属性,类似于装饰器.
    * setattr(objName,  proName, proValue): 可以动态的添加属性, 与静态的语言不一样。
    * hasattr(objName,  proName,): 判断是否存在某个属性
    * getattr(objName, proName): 获取某个属性的值， 无法获取私有变量；
    * \_\_str__(self): 设置类型说明;
    * \_\_repr__(self): 设置开发者视图下的类型说明;
    * \_\_iter__, next(): 迭代器实现,使其可以进行 for in 的循环;
    * \_\_getitem__： 实现下标获得数组， 对[]的重载！
    * \_\_getattr__: 预设不存在的属性
    * \_\_call__： 实例直接当做方法用，callable（obj）, 可以判断是否可以实例当做函数

### 6.2 继承： 
* 定义形式: class ChildClass(SuperClass1, SuperClass2, SuperClass3........)
* 完整的继承功能, 子类拥有父类的所有属性方法，并且无法改动父类的内容，子类定义的内容会覆盖父类相同的内容.
       
### 6.3 多态：
* 将指向父类对象的引用指向子类对象就可以使用子类派生出的功能

### 6.4 其他特性
* type: class 是通过type函数创建-type(className, (SuperClassTuple), dict(methodName));
* MethodType：动态为类型添加属性和名字;

## 异常与调试
* 异常： 与C++类似，定义了异常类的树，try .exception， finally 捕获异常， raise 抛出异常；
如果出错没有被捕获最终会被解释器捕获，程序结束。
* 调试： print ,assert, logging.







